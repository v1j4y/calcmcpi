<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>calcmcpi</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="/home/chilkuri/.pandoc/github-markdown.css" />
</head>
<body>
<div class="HEADER drawer">

</div>

<h1 id="introduction">Introduction</h1>
<p>The one dimensional integral that we shall evaluate using monte-carlo methods gives the area of the a quarter of the unit circle. Using this and the fact that the analytical value of the are of a quarter of the unit circle is given as (\pi/4), we can find the value of (\pi).</p>
<p>[ I = \int_0^1 f(x,y)\ dx = \int_0^1 \sqrt{1-x^2}\ dx = \frac{\pi}{4} ]</p>
<p><img src="/figures/area_quarter_unit_circle.png" /></p>
<p>The goal is to understand the strengths and weaknesses of the various monte-carlo methods for the purpose of numerical integration.</p>
<h1 id="monte-carlo-methods">Monte-Carlo methods</h1>
<p>Here, we shall test the various algorithms for numerical integration and check their labour ratio.</p>
<h2 id="hit-or-miss">Hit or Miss</h2>
<p>The crude method is the simplest and most inefficient monte-carlo algorithm. It simply involves generating uniformly distributed random points inside the unit square and counting the ratio of those points that lie within the quarter circle. This gives us the ratio of the area of the square and the circle. Since the are of the unit square is 1, the are of the circle can be deduced directly.</p>
<p><img src="/figures/hit_and_miss_sampling.png" /></p>
<p>The algorithm involves simply generating uniformly distributed set of points within the range (0-1). The function we want to sample is given as.</p>
<p>[ \begin{equation} g(x,y) = \left{ \begin{array}{ll} 1 &amp; \mbox{if } \sqrt{1-x^2} \le 1 \ 0 &amp; \mbox{if } \sqrt{1-x^2} &gt; 1 \end{array} \right. \end{equation} ]</p>
<p>Then the estimator given below is an unbiased estimator for the integral (\theta) for uniformly generated points ((x_i,y_i)) within the unit square ((1,1)).</p>
<p>[ \theta = \sum_i^N \frac{g(x_i,y_i)}{N} ]</p>
<h3 id="code">Code</h3>
<ol>
<li><p>Functions</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">def</span> hit_or_miss(p):</a>
<a class="sourceLine" id="cb1-2" title="2">    (x, y) <span class="op">=</span> p</a>
<a class="sourceLine" id="cb1-3" title="3">    <span class="cf">if</span> np.sqrt(x<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> y<span class="op">**</span><span class="dv">2</span>) <span class="op">&gt;</span> <span class="dv">1</span>:</a>
<a class="sourceLine" id="cb1-4" title="4">        <span class="cf">return</span>(<span class="dv">0</span>)</a>
<a class="sourceLine" id="cb1-5" title="5">    <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb1-6" title="6">        <span class="cf">return</span>(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb1-7" title="7"></a>
<a class="sourceLine" id="cb1-8" title="8"><span class="kw">def</span> hit_or_miss_var(inp):</a>
<a class="sourceLine" id="cb1-9" title="9">    (x, meanpi) <span class="op">=</span> inp</a>
<a class="sourceLine" id="cb1-10" title="10">    <span class="cf">return</span>((x<span class="op">-</span>meanpi)<span class="op">**</span><span class="dv">2</span>)</a></code></pre></div></li>
<li><p>Simulation</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb2-1" title="1">nb<span class="op">=</span><span class="dv">24</span></a>
<a class="sourceLine" id="cb2-2" title="2">corrlen<span class="op">=</span><span class="dv">0</span></a>
<a class="sourceLine" id="cb2-3" title="3">npoints<span class="op">=</span>(<span class="dv">1</span> <span class="op">&lt;&lt;</span> nb )</a>
<a class="sourceLine" id="cb2-4" title="4">npointsall<span class="op">=</span>(<span class="dv">1</span> <span class="op">&lt;&lt;</span> nb ) <span class="op">+</span> corrlen</a>
<a class="sourceLine" id="cb2-5" title="5">randvalsx <span class="op">=</span> np.random.rand(npointsall)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-6" title="6">randvalsy <span class="op">=</span> np.random.rand(npointsall)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-7" title="7">pivalslist<span class="op">=</span>np.zeros(npointsall)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-8" title="8"></a>
<a class="sourceLine" id="cb2-9" title="9"><span class="co"># Calculate via MC simul</span></a>
<a class="sourceLine" id="cb2-10" title="10">meanpi <span class="op">=</span> st.mean(<span class="bu">map</span>(hit_or_miss, <span class="bu">zip</span>(randvalsx,randvalsy)))</a>
<a class="sourceLine" id="cb2-11" title="11">pivals <span class="op">=</span> <span class="bu">map</span>(hit_or_miss, <span class="bu">zip</span>(randvalsx,randvalsy))</a>
<a class="sourceLine" id="cb2-12" title="12">meanpilist <span class="op">=</span> meanpi<span class="op">*</span>np.ones(npoints)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-13" title="13">varpivals <span class="op">=</span> <span class="bu">map</span>(hit_or_miss_var, <span class="bu">zip</span>(pivals,meanpilist))</a>
<a class="sourceLine" id="cb2-14" title="14">errorpi<span class="op">=</span>np.sqrt(<span class="bu">sum</span>(varpivals)<span class="op">/</span>(npoints<span class="dv">-1</span>))<span class="op">/</span>np.sqrt(npoints)</a>
<a class="sourceLine" id="cb2-15" title="15"><span class="co"># π</span></a>
<a class="sourceLine" id="cb2-16" title="16">exactI<span class="op">=</span>np.pi<span class="op">/</span><span class="dv">4</span></a>
<a class="sourceLine" id="cb2-17" title="17"><span class="bu">print</span>(<span class="ss">f&#39;meanpi = </span><span class="sc">{</span>meanpi<span class="sc">}</span><span class="ss"> exact=</span><span class="sc">{</span>exactI<span class="sc">}</span><span class="ss"> </span><span class="ch">\n</span><span class="ss"> error=</span><span class="sc">{</span>errorpi<span class="sc">}</span><span class="ss"> errorExact=</span><span class="sc">{</span>exactI<span class="op">-</span>meanpi<span class="sc">}</span><span class="ss">&#39;</span>)</a>
<a class="sourceLine" id="cb2-18" title="18"></a>
<a class="sourceLine" id="cb2-19" title="19"><span class="co"># Results</span></a></code></pre></div></li>
</ol>
<h3 id="code-output">Code (Output)</h3>
<pre class="example"><code>meanpi = 0.785393238067627 exact=0.7853981633974483
 error=0.00010023175734353169 errorExact=4.9253298213258745e-06
</code></pre>
<h2 id="crude-monte-carlo">Crude monte-carlo</h2>
<p>The crude method is the simplest and most inefficient monte-carlo algorithm. It simply involves generating uniformly distributed random points inside the unit square and counting the ratio of those points that lie within the quarter circle. This gives us the ratio of the area of the square and the circle. Since the are of the unit square is 1, the are of the circle can be deduced directly.</p>
<p><img src="/figures/crude_sampling.png" /></p>
<p>The algorithm involves simply generating uniformly distributed set of points within the range (0-1). The estimator for the integral (I) is given below.</p>
<p>[ \theta = \sum_i^N \frac{f(\xi_i)}{N} ]</p>
<p>with f being the function given as shown below.</p>
<p>[ f(x) = \sqrt{1 - x^2} ]</p>
<p>and (\xi_i) is a uniform random number betwee ((0,1)).</p>
<h3 id="code-1">Code</h3>
<ol>
<li><p>Functions</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">def</span> pi_curve(x):</a>
<a class="sourceLine" id="cb4-2" title="2">    <span class="cf">return</span>(np.sqrt(<span class="fl">1.0</span> <span class="op">-</span> x<span class="op">*</span>x))</a>
<a class="sourceLine" id="cb4-3" title="3"></a>
<a class="sourceLine" id="cb4-4" title="4"><span class="kw">def</span> pi_curve_var(inp):</a>
<a class="sourceLine" id="cb4-5" title="5">    (x, meanpi) <span class="op">=</span> inp</a>
<a class="sourceLine" id="cb4-6" title="6">    <span class="cf">return</span>((x<span class="op">-</span>meanpi)<span class="op">**</span><span class="dv">2</span>)</a></code></pre></div></li>
<li><p>Simulation</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb5-1" title="1">nb<span class="op">=</span><span class="dv">24</span></a>
<a class="sourceLine" id="cb5-2" title="2">corrlen<span class="op">=</span><span class="dv">0</span></a>
<a class="sourceLine" id="cb5-3" title="3">npoints<span class="op">=</span>(<span class="dv">1</span> <span class="op">&lt;&lt;</span> nb )</a>
<a class="sourceLine" id="cb5-4" title="4">npointsall<span class="op">=</span>(<span class="dv">1</span> <span class="op">&lt;&lt;</span> nb ) <span class="op">+</span> corrlen</a>
<a class="sourceLine" id="cb5-5" title="5">randvals <span class="op">=</span> np.random.rand(npointsall)<span class="op">;</span></a>
<a class="sourceLine" id="cb5-6" title="6">pivalslist<span class="op">=</span>np.zeros(npointsall)<span class="op">;</span></a>
<a class="sourceLine" id="cb5-7" title="7"></a>
<a class="sourceLine" id="cb5-8" title="8"><span class="co"># Calculate via MC simul</span></a>
<a class="sourceLine" id="cb5-9" title="9">meanpi <span class="op">=</span> st.mean(<span class="bu">map</span>(pi_curve, randvals))</a>
<a class="sourceLine" id="cb5-10" title="10">pivals <span class="op">=</span> <span class="bu">map</span>(pi_curve, randvals)</a>
<a class="sourceLine" id="cb5-11" title="11">meanpilist <span class="op">=</span> meanpi<span class="op">*</span>np.ones(npoints)<span class="op">;</span></a>
<a class="sourceLine" id="cb5-12" title="12">varpivals <span class="op">=</span> <span class="bu">map</span>(pi_curve_var, <span class="bu">zip</span>(pivals,meanpilist))</a>
<a class="sourceLine" id="cb5-13" title="13">errorpi<span class="op">=</span>np.sqrt(<span class="bu">sum</span>(varpivals)<span class="op">/</span>(npoints<span class="dv">-1</span>))<span class="op">/</span>np.sqrt(npoints)</a>
<a class="sourceLine" id="cb5-14" title="14"><span class="co"># π</span></a>
<a class="sourceLine" id="cb5-15" title="15">exactI<span class="op">=</span>np.pi<span class="op">/</span><span class="dv">4</span></a>
<a class="sourceLine" id="cb5-16" title="16"><span class="bu">print</span>(<span class="ss">f&#39;meanpi = </span><span class="sc">{</span>meanpi<span class="sc">}</span><span class="ss"> exact=</span><span class="sc">{</span>exactI<span class="sc">}</span><span class="ss"> </span><span class="ch">\n</span><span class="ss"> error=</span><span class="sc">{</span>errorpi<span class="sc">}</span><span class="ss"> errorExact=</span><span class="sc">{</span>exactI<span class="op">-</span>meanpi<span class="sc">}</span><span class="ss">&#39;</span>)</a>
<a class="sourceLine" id="cb5-17" title="17"></a></code></pre></div></li>
</ol>
<h3 id="code-output-1">Code (Output)</h3>
<pre class="example"><code>meanpi = 0.7854022279396252 exact=0.7853981633974483
 error=5.447856099833516e-05 errorExact=-4.0645421769403e-06
</code></pre>
<h2 id="stratified-sampling">Stratified sampling</h2>
<p>Stratified sampling involves breaking up the domain (i.e. 0 - 1) into strata and sampling inside individual strata. The estimator for (\pi/4) is then given by the following.</p>
<p>[ \theta = \sum_{j=1}^k \sum_1^{n_j} (\alpha_j - \alpha_{j-1})\frac{1}{n_j}f(\alpha_{j-1}+(\alpha_j - \alpha_{j-1})\xi_{ij}) ]</p>
<p>The variance can be smaller than that of crude monte-carlo if differences between local means is larger than the variance of (f) within the stata.</p>
<p><img src="/figures/stratified_sampling.png" /></p>
<h3 id="code-2">Code</h3>
<ol>
<li><p>Function</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">def</span> interval_gen(nint):</a>
<a class="sourceLine" id="cb7-2" title="2">    <span class="cf">return</span>(np.linspace(<span class="dv">0</span>,<span class="dv">1</span>,nint<span class="op">+</span><span class="dv">1</span>))</a>
<a class="sourceLine" id="cb7-3" title="3"></a>
<a class="sourceLine" id="cb7-4" title="4"><span class="kw">def</span> strat_rand(x, a, b):</a>
<a class="sourceLine" id="cb7-5" title="5">    <span class="cf">return</span>( a <span class="op">+</span> x<span class="op">*</span>(b<span class="op">-</span>a) )</a>
<a class="sourceLine" id="cb7-6" title="6"></a>
<a class="sourceLine" id="cb7-7" title="7"><span class="kw">def</span> strat_calc(x,</a>
<a class="sourceLine" id="cb7-8" title="8">                list_npoints_inter,</a>
<a class="sourceLine" id="cb7-9" title="9">                list_sum_inter,</a>
<a class="sourceLine" id="cb7-10" title="10">                list_sum_inter2,</a>
<a class="sourceLine" id="cb7-11" title="11">                list_sum_inter_witha,</a>
<a class="sourceLine" id="cb7-12" title="12">                inter_list):</a>
<a class="sourceLine" id="cb7-13" title="13">    idinter <span class="op">=</span> np.searchsorted(inter_list,x)<span class="op">-</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb7-14" title="14">    list_npoints_inter[idinter] <span class="op">+=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb7-15" title="15">    list_sum_inter[idinter] <span class="op">+=</span> (pi_curve(x))</a>
<a class="sourceLine" id="cb7-16" title="16">    δa <span class="op">=</span> inter_list[idinter<span class="op">+</span><span class="dv">1</span>]<span class="op">-</span>inter_list[idinter]<span class="op">;</span></a>
<a class="sourceLine" id="cb7-17" title="17">    list_sum_inter_witha[idinter] <span class="op">+=</span> δa <span class="op">*</span> (pi_curve(x))</a>
<a class="sourceLine" id="cb7-18" title="18">    list_sum_inter2[idinter] <span class="op">+=</span> pi_curve(x) <span class="op">*</span> pi_curve(x)</a>
<a class="sourceLine" id="cb7-19" title="19"></a>
<a class="sourceLine" id="cb7-20" title="20"><span class="kw">def</span> strat_rand_calc(x, a, b,</a>
<a class="sourceLine" id="cb7-21" title="21">                list_npoints_inter,</a>
<a class="sourceLine" id="cb7-22" title="22">                list_sum_inter,</a>
<a class="sourceLine" id="cb7-23" title="23">                list_sum_inter2,</a>
<a class="sourceLine" id="cb7-24" title="24">                list_sum_inter_witha,</a>
<a class="sourceLine" id="cb7-25" title="25">                inter_list):</a>
<a class="sourceLine" id="cb7-26" title="26">    x <span class="op">=</span> ( a <span class="op">+</span> x<span class="op">*</span>(b<span class="op">-</span>a) )</a>
<a class="sourceLine" id="cb7-27" title="27">    idinter <span class="op">=</span> np.searchsorted(inter_list,x)<span class="op">-</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb7-28" title="28">    list_npoints_inter[idinter] <span class="op">+=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb7-29" title="29">    list_sum_inter[idinter] <span class="op">+=</span> (pi_curve(x))</a>
<a class="sourceLine" id="cb7-30" title="30">    δa <span class="op">=</span> inter_list[idinter<span class="op">+</span><span class="dv">1</span>]<span class="op">-</span>inter_list[idinter]<span class="op">;</span></a>
<a class="sourceLine" id="cb7-31" title="31">    list_sum_inter_witha[idinter] <span class="op">+=</span> δa <span class="op">*</span> (pi_curve(x))</a>
<a class="sourceLine" id="cb7-32" title="32">    list_sum_inter2[idinter] <span class="op">+=</span> pi_curve(x) <span class="op">*</span> pi_curve(x)</a>
<a class="sourceLine" id="cb7-33" title="33"></a></code></pre></div></li>
<li><p>Simulation</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb8-1" title="1">nb <span class="op">=</span> <span class="dv">10</span></a>
<a class="sourceLine" id="cb8-2" title="2">npint <span class="op">=</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb8-3" title="3">nint <span class="op">=</span> <span class="dv">1</span> <span class="op">&lt;&lt;</span> npint</a>
<a class="sourceLine" id="cb8-4" title="4">corrlen<span class="op">=</span><span class="dv">0</span></a>
<a class="sourceLine" id="cb8-5" title="5">npoints<span class="op">=</span>(<span class="dv">1</span> <span class="op">&lt;&lt;</span> nb )</a>
<a class="sourceLine" id="cb8-6" title="6">npointsall<span class="op">=</span>(<span class="dv">1</span> <span class="op">&lt;&lt;</span> nb )</a>
<a class="sourceLine" id="cb8-7" title="7">randvals <span class="op">=</span> np.random.rand(npointsall)</a>
<a class="sourceLine" id="cb8-8" title="8"><span class="bu">print</span>(npointsall)</a>
<a class="sourceLine" id="cb8-9" title="9">list_npoints_inter <span class="op">=</span> np.zeros(nint,dtype<span class="op">=</span><span class="bu">int</span>)</a>
<a class="sourceLine" id="cb8-10" title="10">list_sum_inter <span class="op">=</span> np.zeros(nint)</a>
<a class="sourceLine" id="cb8-11" title="11">list_sum_inter2 <span class="op">=</span> np.zeros(nint)</a>
<a class="sourceLine" id="cb8-12" title="12">list_sum_inter_witha <span class="op">=</span> np.zeros(nint)</a>
<a class="sourceLine" id="cb8-13" title="13">inter_list <span class="op">=</span> interval_gen(nint)</a>
<a class="sourceLine" id="cb8-14" title="14">list_mean_inter <span class="op">=</span> np.zeros(nint)</a>
<a class="sourceLine" id="cb8-15" title="15"></a>
<a class="sourceLine" id="cb8-16" title="16"><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(nint):</a>
<a class="sourceLine" id="cb8-17" title="17">    step <span class="op">=</span> npointsall <span class="op">&gt;&gt;</span> npint</a>
<a class="sourceLine" id="cb8-18" title="18">    a <span class="op">=</span> inter_list[i]</a>
<a class="sourceLine" id="cb8-19" title="19">    b <span class="op">=</span> inter_list[i<span class="op">+</span><span class="dv">1</span>]</a>
<a class="sourceLine" id="cb8-20" title="20">    [ strat_rand_calc(x, a, b,</a>
<a class="sourceLine" id="cb8-21" title="21">                      list_npoints_inter,</a>
<a class="sourceLine" id="cb8-22" title="22">                      list_sum_inter,</a>
<a class="sourceLine" id="cb8-23" title="23">                      list_sum_inter2,</a>
<a class="sourceLine" id="cb8-24" title="24">                      list_sum_inter_witha,</a>
<a class="sourceLine" id="cb8-25" title="25">                      inter_list) <span class="cf">for</span> x <span class="kw">in</span> randvals[step<span class="op">*</span>(i):step<span class="op">*</span>(i<span class="op">+</span><span class="dv">1</span>)]]</a>
<a class="sourceLine" id="cb8-26" title="26"></a>
<a class="sourceLine" id="cb8-27" title="27">list_mean_inter <span class="op">=</span> [i<span class="op">/</span>j <span class="cf">for</span> i,j <span class="kw">in</span></a>
<a class="sourceLine" id="cb8-28" title="28">                   <span class="bu">zip</span>(list_sum_inter_witha,list_npoints_inter)]</a>
<a class="sourceLine" id="cb8-29" title="29"></a>
<a class="sourceLine" id="cb8-30" title="30">meanpi<span class="op">=</span>np.<span class="bu">sum</span>(list_mean_inter)<span class="op">;</span></a>
<a class="sourceLine" id="cb8-31" title="31">varpi <span class="op">=</span> <span class="fl">0.0</span><span class="op">;</span></a>
<a class="sourceLine" id="cb8-32" title="32"><span class="cf">for</span> it <span class="kw">in</span> <span class="bu">range</span>(nint):</a>
<a class="sourceLine" id="cb8-33" title="33">    δa <span class="op">=</span> inter_list[it<span class="op">+</span><span class="dv">1</span>] <span class="op">-</span> inter_list[it]<span class="op">;</span></a>
<a class="sourceLine" id="cb8-34" title="34">    nit <span class="op">=</span> list_npoints_inter[it]</a>
<a class="sourceLine" id="cb8-35" title="35">    varpi <span class="op">+=</span> δa <span class="op">*</span> δa <span class="op">*</span> ( list_sum_inter2[it] <span class="op">-</span> nit <span class="op">*</span> list_mean_inter[it] <span class="op">*</span> list_mean_inter[it] )<span class="op">/</span>(nit <span class="op">*</span> (nit <span class="op">-</span> <span class="dv">1</span>))<span class="op">;</span></a>
<a class="sourceLine" id="cb8-36" title="36"></a>
<a class="sourceLine" id="cb8-37" title="37">errorpi <span class="op">=</span> np.sqrt(varpi)</a>
<a class="sourceLine" id="cb8-38" title="38">exactI<span class="op">=</span><span class="fl">0.4180232931306735</span></a>
<a class="sourceLine" id="cb8-39" title="39">exactI<span class="op">=</span>np.pi<span class="op">/</span><span class="dv">4</span></a>
<a class="sourceLine" id="cb8-40" title="40"><span class="bu">print</span>(<span class="ss">f&#39;meanpi = </span><span class="sc">{</span>meanpi<span class="sc">}</span><span class="ss"> exact=</span><span class="sc">{</span>exactI<span class="sc">}</span><span class="ss"> </span><span class="ch">\n</span><span class="ss"> error=</span><span class="sc">{</span>errorpi<span class="sc">}</span><span class="ss"> errorExact=</span><span class="sc">{</span>exactI<span class="op">-</span>meanpi<span class="sc">}</span><span class="ss">&#39;</span>)</a></code></pre></div></li>
</ol>
<h3 id="code-output-2">Code (output)</h3>
<pre class="example"><code>meanpi = 0.7831097344059315 exact=0.7853981633974483
 error=0.024708860632964468 errorExact=0.002288428991516822
</code></pre>
<h2 id="importance-sampling">Importance sampling</h2>
<p>The natural next step following stratified sampling is that of importance sampling. In the previous method, we chose the strata arbitrarily, i.e. by inspection of the function to integrate. This was followed by a uniform sampling of points inside each strata. The idea is to break the domain into regions which need to be sampled with more points as opposed to domains where the function is quasi horizontal (i.e. low variance). The more natural way to do this is to adapt the choice of points in a more flexible manner. This is the idea behind importance sampling where we define a custom distribution ((g(x))) which is very close to the original function ((f(x))) that we wish to integrate. The main constarint on the distribution is that it needs to be easy to sample from.</p>
<p>[ \theta = \int_0^1 f(x)\ dx = \int_0^1 \frac{f(x)}{g(x)} g{x}\ dx = \int_0^1 \frac{f(x)}{g(x)} dG(x) ]</p>
<p>here, (dG(x)) is the measure, i.e. the sampling distribution. Note that the distribution (g(x)) must be normalized.</p>
<p>[ \int_0^1 g(x)dx = 1 ]</p>
<p>Invting a distribution,</p>
<h3 id="code-3">Code</h3>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb10-1" title="1"></a>
<a class="sourceLine" id="cb10-2" title="2"><span class="co"># &quot;path&quot; variable must be set by block that</span></a>
<a class="sourceLine" id="cb10-3" title="3"><span class="co"># expands this org source code block</span></a>
<a class="sourceLine" id="cb10-4" title="4"><span class="co">&quot;[[./&quot;</span><span class="op">+</span>path<span class="op">+</span><span class="st">&quot;]]&quot;</span></a></code></pre></div>
<ol>
<li><p>Function</p>
<div class="RESULTS drawer">

<p><img src="/figures/sampling_function.png" /></p>
</div>

<p>The above figure shows the distribution function that we shall use. There are many points close to (x\approx0) and the points progressively decrease as we approach (x\approx1).</p></li>
<li><p>Simulation</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb11-1" title="1">nb<span class="op">=</span><span class="dv">22</span></a>
<a class="sourceLine" id="cb11-2" title="2">corrlen<span class="op">=</span><span class="dv">0</span></a>
<a class="sourceLine" id="cb11-3" title="3">npoints<span class="op">=</span>(<span class="dv">1</span> <span class="op">&lt;&lt;</span> nb )</a>
<a class="sourceLine" id="cb11-4" title="4">npointsall<span class="op">=</span>(<span class="dv">1</span> <span class="op">&lt;&lt;</span> nb ) <span class="op">+</span> corrlen</a>
<a class="sourceLine" id="cb11-5" title="5">randvals <span class="op">=</span> [cdfm1(x) <span class="cf">for</span> x <span class="kw">in</span> np.random.rand(npointsall)]</a>
<a class="sourceLine" id="cb11-6" title="6"></a>
<a class="sourceLine" id="cb11-7" title="7"><span class="co"># Calculate via MC simul</span></a>
<a class="sourceLine" id="cb11-8" title="8">pivals <span class="op">=</span> [foverg(x) <span class="cf">for</span> x <span class="kw">in</span> randvals]</a>
<a class="sourceLine" id="cb11-9" title="9">meanpi <span class="op">=</span> st.mean(pivals)</a>
<a class="sourceLine" id="cb11-10" title="10">meanpilist <span class="op">=</span> meanpi<span class="op">*</span>np.ones(npoints)<span class="op">;</span></a>
<a class="sourceLine" id="cb11-11" title="11">varpivals <span class="op">=</span> [pi_curve_var(x) <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">zip</span>(pivals,meanpilist)]</a>
<a class="sourceLine" id="cb11-12" title="12">errorpi<span class="op">=</span>np.sqrt(np.<span class="bu">sum</span>(varpivals)<span class="op">/</span>(npoints<span class="dv">-1</span>))<span class="op">/</span>np.sqrt(npoints)</a>
<a class="sourceLine" id="cb11-13" title="13">exactI<span class="op">=</span>np.pi<span class="op">/</span><span class="dv">4</span></a>
<a class="sourceLine" id="cb11-14" title="14"></a>
<a class="sourceLine" id="cb11-15" title="15"><span class="bu">print</span>(<span class="ss">f&#39;meanpi = </span><span class="sc">{</span>meanpi<span class="sc">}</span><span class="ss"> exact=</span><span class="sc">{</span>exactI<span class="sc">}</span><span class="ss"> </span><span class="ch">\n</span><span class="ss"> error=</span><span class="sc">{</span>errorpi<span class="sc">}</span><span class="ss"> errorExact=</span><span class="sc">{</span>exactI<span class="op">-</span>meanpi<span class="sc">}</span><span class="ss">&#39;</span>)</a></code></pre></div></li>
</ol>
<h3 id="coderesults">Code(results)</h3>
<pre class="example"><code>meanpi = 0.7858500513037664 exact=0.7853981633974483
 error=0.0008344871199825027 errorExact=-0.0004518879063181158
</code></pre>
</body>
</html>
