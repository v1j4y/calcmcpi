<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>calcmcpi</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#introduction" id="toc-introduction">Introduction</a></li>
<li><a href="#monte-carlo-methods"
id="toc-monte-carlo-methods">Monte-Carlo methods</a>
<ul>
<li><a href="#hit-or-miss" id="toc-hit-or-miss">Hit or Miss</a>
<ul>
<li><a href="#code" id="toc-code">Code</a></li>
<li><a href="#code-output" id="toc-code-output">Code (Output)</a></li>
</ul></li>
<li><a href="#crude-monte-carlo" id="toc-crude-monte-carlo">Crude
monte-carlo</a>
<ul>
<li><a href="#code-1" id="toc-code-1">Code</a></li>
<li><a href="#code-output-1" id="toc-code-output-1">Code
(Output)</a></li>
</ul></li>
<li><a href="#stratified-sampling"
id="toc-stratified-sampling">Stratified sampling</a>
<ul>
<li><a href="#code-2" id="toc-code-2">Code</a></li>
<li><a href="#code-output-2" id="toc-code-output-2">Code
(output)</a></li>
</ul></li>
<li><a href="#importance-sampling"
id="toc-importance-sampling">Importance sampling</a>
<ul>
<li><a href="#code-3" id="toc-code-3">Code</a></li>
<li><a href="#coderesults" id="toc-coderesults">Code(results)</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
<div class="HEADER drawer">

</div>

<h1 id="introduction">Introduction</h1>
<p>The one dimensional integral that we shall evaluate using monte-carlo
methods gives the area of the a quarter of the unit circle. Using this
and the fact that the analytical value of the are of a quarter of the
unit circle is given as <span class="math inline">\(\pi/4\)</span>, we
can find the value of <span class="math inline">\(\pi\)</span>.</p>
<p><span class="math display">\[
I = \int_0^1 f(x,y)\ dx = \int_0^1 \sqrt{1-x^2}\ dx = \frac{\pi}{4}
\]</span></p>
<p><img src="figures/area_quarter_unit_circle.png" /></p>
<p>The goal is to understand the strengths and weaknesses of the various
monte-carlo methods for the purpose of numerical integration.</p>
<h1 id="monte-carlo-methods">Monte-Carlo methods</h1>
<p>Here, we shall test the various algorithms for numerical integration
and check their labour ratio.</p>
<h2 id="hit-or-miss">Hit or Miss</h2>
<p>The crude method is the simplest and most inefficient monte-carlo
algorithm. It simply involves generating uniformly distributed random
points inside the unit square and counting the ratio of those points
that lie within the quarter circle. This gives us the ratio of the area
of the square and the circle. Since the are of the unit square is 1, the
are of the circle can be deduced directly.</p>
<p><img src="figures/hit_and_miss_sampling.png" /></p>
<p>The algorithm involves simply generating uniformly distributed set of
points within the range (0-1). The function we want to sample is given
as.</p>
<p><span class="math display">\[
\begin{equation}
g(x,y) =
\left\{
\begin{array}{ll}
1  &amp; \mbox{if } \sqrt{1-x^2} \le 1 \\
0  &amp; \mbox{if } \sqrt{1-x^2} &gt; 1
\end{array}
\right.
\end{equation}
\]</span></p>
<p>Then the estimator given below is an unbiased estimator for the
integral <span class="math inline">\(\theta\)</span> for uniformly
generated points (<span class="math inline">\(x_i,y_i\)</span>) within
the unit square (<span class="math inline">\(1,1\)</span>).</p>
<p><span class="math display">\[
\theta = \sum_i^N \frac{g(x_i,y_i)}{N}
\]</span></p>
<h3 id="code">Code</h3>
<ol type="1">
<li><p>Functions</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> hit_or_miss(p):</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    (x, y) <span class="op">=</span> p</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> np.sqrt(x<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> y<span class="op">**</span><span class="dv">2</span>) <span class="op">&gt;</span> <span class="dv">1</span>:</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span>(<span class="dv">0</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span>(<span class="dv">1</span>)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> hit_or_miss_var(inp):</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    (x, meanpi) <span class="op">=</span> inp</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span>((x<span class="op">-</span>meanpi)<span class="op">**</span><span class="dv">2</span>)</span></code></pre></div></li>
<li><p>Simulation</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>nb<span class="op">=</span><span class="dv">24</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>corrlen<span class="op">=</span><span class="dv">0</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>npoints<span class="op">=</span>(<span class="dv">1</span> <span class="op">&lt;&lt;</span> nb )</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>npointsall<span class="op">=</span>(<span class="dv">1</span> <span class="op">&lt;&lt;</span> nb ) <span class="op">+</span> corrlen</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>randvalsx <span class="op">=</span> np.random.rand(npointsall)<span class="op">;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>randvalsy <span class="op">=</span> np.random.rand(npointsall)<span class="op">;</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>pivalslist<span class="op">=</span>np.zeros(npointsall)<span class="op">;</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate via MC simul</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>meanpi <span class="op">=</span> st.mean(<span class="bu">map</span>(hit_or_miss, <span class="bu">zip</span>(randvalsx,randvalsy)))</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>pivals <span class="op">=</span> <span class="bu">map</span>(hit_or_miss, <span class="bu">zip</span>(randvalsx,randvalsy))</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>meanpilist <span class="op">=</span> meanpi<span class="op">*</span>np.ones(npoints)<span class="op">;</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>varpivals <span class="op">=</span> <span class="bu">map</span>(hit_or_miss_var, <span class="bu">zip</span>(pivals,meanpilist))</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>errorpi<span class="op">=</span>np.sqrt(<span class="bu">sum</span>(varpivals)<span class="op">/</span>(npoints<span class="op">-</span><span class="dv">1</span>))<span class="op">/</span>np.sqrt(npoints)</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="co"># π</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>exactI<span class="op">=</span>np.pi<span class="op">/</span><span class="dv">4</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&#39;meanpi = </span><span class="sc">{</span>meanpi<span class="sc">}</span><span class="ss"> exact=</span><span class="sc">{</span>exactI<span class="sc">}</span><span class="ss"> </span><span class="ch">\n</span><span class="ss"> error=</span><span class="sc">{</span>errorpi<span class="sc">}</span><span class="ss"> errorExact=</span><span class="sc">{</span>exactI<span class="op">-</span>meanpi<span class="sc">}</span><span class="ss">&#39;</span>)</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Results</span></span></code></pre></div></li>
</ol>
<h3 id="code-output">Code (Output)</h3>
<pre class="example"><code>meanpi = 0.785393238067627 exact=0.7853981633974483
 error=0.00010023175734353169 errorExact=4.9253298213258745e-06</code></pre>
<h2 id="crude-monte-carlo">Crude monte-carlo</h2>
<p>The crude method is the simplest and most inefficient monte-carlo
algorithm. It simply involves generating uniformly distributed random
points inside the unit square and counting the ratio of those points
that lie within the quarter circle. This gives us the ratio of the area
of the square and the circle. Since the are of the unit square is 1, the
are of the circle can be deduced directly.</p>
<p><img src="figures/crude_sampling.png" /></p>
<p>The algorithm involves simply generating uniformly distributed set of
points within the range (0-1). The estimator for the integral <span
class="math inline">\(I\)</span> is given below.</p>
<p><span class="math display">\[
\theta = \sum_i^N \frac{f(\xi_i)}{N}
\]</span></p>
<p>with f being the function given as shown below.</p>
<p><span class="math display">\[
f(x) = \sqrt{1 - x^2}
\]</span></p>
<p>and <span class="math inline">\(\xi_i\)</span> is a uniform random
number betwee (<span class="math inline">\(0,1\)</span>).</p>
<h3 id="code-1">Code</h3>
<ol type="1">
<li><p>Functions</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> pi_curve(x):</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span>(np.sqrt(<span class="fl">1.0</span> <span class="op">-</span> x<span class="op">*</span>x))</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> pi_curve_var(inp):</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    (x, meanpi) <span class="op">=</span> inp</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span>((x<span class="op">-</span>meanpi)<span class="op">**</span><span class="dv">2</span>)</span></code></pre></div></li>
<li><p>Simulation</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>nb<span class="op">=</span><span class="dv">24</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>corrlen<span class="op">=</span><span class="dv">0</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>npoints<span class="op">=</span>(<span class="dv">1</span> <span class="op">&lt;&lt;</span> nb )</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>npointsall<span class="op">=</span>(<span class="dv">1</span> <span class="op">&lt;&lt;</span> nb ) <span class="op">+</span> corrlen</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>randvals <span class="op">=</span> np.random.rand(npointsall)<span class="op">;</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>pivalslist<span class="op">=</span>np.zeros(npointsall)<span class="op">;</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate via MC simul</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>meanpi <span class="op">=</span> st.mean(<span class="bu">map</span>(pi_curve, randvals))</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>pivals <span class="op">=</span> <span class="bu">map</span>(pi_curve, randvals)</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>meanpilist <span class="op">=</span> meanpi<span class="op">*</span>np.ones(npoints)<span class="op">;</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>varpivals <span class="op">=</span> <span class="bu">map</span>(pi_curve_var, <span class="bu">zip</span>(pivals,meanpilist))</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>errorpi<span class="op">=</span>np.sqrt(<span class="bu">sum</span>(varpivals)<span class="op">/</span>(npoints<span class="op">-</span><span class="dv">1</span>))<span class="op">/</span>np.sqrt(npoints)</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a><span class="co"># π</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>exactI<span class="op">=</span>np.pi<span class="op">/</span><span class="dv">4</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&#39;meanpi = </span><span class="sc">{</span>meanpi<span class="sc">}</span><span class="ss"> exact=</span><span class="sc">{</span>exactI<span class="sc">}</span><span class="ss"> </span><span class="ch">\n</span><span class="ss"> error=</span><span class="sc">{</span>errorpi<span class="sc">}</span><span class="ss"> errorExact=</span><span class="sc">{</span>exactI<span class="op">-</span>meanpi<span class="sc">}</span><span class="ss">&#39;</span>)</span></code></pre></div></li>
</ol>
<h3 id="code-output-1">Code (Output)</h3>
<pre class="example"><code>meanpi = 0.7854022279396252 exact=0.7853981633974483
 error=5.447856099833516e-05 errorExact=-4.0645421769403e-06</code></pre>
<h2 id="stratified-sampling">Stratified sampling</h2>
<p>Stratified sampling involves breaking up the domain (i.e. 0 - 1) into
strata and sampling inside individual strata. The estimator for <span
class="math inline">\(\pi/4\)</span> is then given by the following.</p>
<p><span class="math display">\[
\theta = \sum_{j=1}^k \sum_1^{n_j} (\alpha_j -
\alpha_{j-1})\frac{1}{n_j}f(\alpha_{j-1}+(\alpha_j -
\alpha_{j-1})\xi_{ij})
\]</span></p>
<p>The variance can be smaller than that of crude monte-carlo if
differences between local means is larger than the variance of <span
class="math inline">\(f\)</span> within the stata.</p>
<p><img src="figures/stratified_sampling.png" /></p>
<h3 id="code-2">Code</h3>
<ol type="1">
<li><p>Function</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> interval_gen(nint):</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span>(np.linspace(<span class="dv">0</span>,<span class="dv">1</span>,nint<span class="op">+</span><span class="dv">1</span>))</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> strat_rand(x, a, b):</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span>( a <span class="op">+</span> x<span class="op">*</span>(b<span class="op">-</span>a) )</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> strat_calc(x,</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>                list_npoints_inter,</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>                list_sum_inter,</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>                list_sum_inter2,</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>                list_sum_inter_witha,</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>                inter_list):</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    idinter <span class="op">=</span> np.searchsorted(inter_list,x)<span class="op">-</span><span class="dv">1</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    list_npoints_inter[idinter] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    list_sum_inter[idinter] <span class="op">+=</span> (pi_curve(x))</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>    δa <span class="op">=</span> inter_list[idinter<span class="op">+</span><span class="dv">1</span>]<span class="op">-</span>inter_list[idinter]<span class="op">;</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>    list_sum_inter_witha[idinter] <span class="op">+=</span> δa <span class="op">*</span> (pi_curve(x))</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>    list_sum_inter2[idinter] <span class="op">+=</span> pi_curve(x) <span class="op">*</span> pi_curve(x)</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> strat_rand_calc(x, a, b,</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>                list_npoints_inter,</span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>                list_sum_inter,</span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>                list_sum_inter2,</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>                list_sum_inter_witha,</span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>                inter_list):</span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> ( a <span class="op">+</span> x<span class="op">*</span>(b<span class="op">-</span>a) )</span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>    idinter <span class="op">=</span> np.searchsorted(inter_list,x)<span class="op">-</span><span class="dv">1</span></span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a>    list_npoints_inter[idinter] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a>    list_sum_inter[idinter] <span class="op">+=</span> (pi_curve(x))</span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a>    δa <span class="op">=</span> inter_list[idinter<span class="op">+</span><span class="dv">1</span>]<span class="op">-</span>inter_list[idinter]<span class="op">;</span></span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a>    list_sum_inter_witha[idinter] <span class="op">+=</span> δa <span class="op">*</span> (pi_curve(x))</span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a>    list_sum_inter2[idinter] <span class="op">+=</span> pi_curve(x) <span class="op">*</span> pi_curve(x)</span></code></pre></div></li>
<li><p>Simulation</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>nb <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>npint <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>nint <span class="op">=</span> <span class="dv">1</span> <span class="op">&lt;&lt;</span> npint</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>corrlen<span class="op">=</span><span class="dv">0</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>npoints<span class="op">=</span>(<span class="dv">1</span> <span class="op">&lt;&lt;</span> nb )</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>npointsall<span class="op">=</span>(<span class="dv">1</span> <span class="op">&lt;&lt;</span> nb )</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>randvals <span class="op">=</span> np.random.rand(npointsall)</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(npointsall)</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>list_npoints_inter <span class="op">=</span> np.zeros(nint,dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>list_sum_inter <span class="op">=</span> np.zeros(nint)</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>list_sum_inter2 <span class="op">=</span> np.zeros(nint)</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>list_sum_inter_witha <span class="op">=</span> np.zeros(nint)</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>inter_list <span class="op">=</span> interval_gen(nint)</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>list_mean_inter <span class="op">=</span> np.zeros(nint)</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(nint):</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>    step <span class="op">=</span> npointsall <span class="op">&gt;&gt;</span> npint</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>    a <span class="op">=</span> inter_list[i]</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>    b <span class="op">=</span> inter_list[i<span class="op">+</span><span class="dv">1</span>]</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>    [ strat_rand_calc(x, a, b,</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>                      list_npoints_inter,</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>                      list_sum_inter,</span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>                      list_sum_inter2,</span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>                      list_sum_inter_witha,</span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>                      inter_list) <span class="cf">for</span> x <span class="kw">in</span> randvals[step<span class="op">*</span>(i):step<span class="op">*</span>(i<span class="op">+</span><span class="dv">1</span>)]]</span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>list_mean_inter <span class="op">=</span> [i<span class="op">/</span>j <span class="cf">for</span> i,j <span class="kw">in</span></span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a>                   <span class="bu">zip</span>(list_sum_inter_witha,list_npoints_inter)]</span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a>meanpi<span class="op">=</span>np.<span class="bu">sum</span>(list_mean_inter)<span class="op">;</span></span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a>varpi <span class="op">=</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> it <span class="kw">in</span> <span class="bu">range</span>(nint):</span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a>    δa <span class="op">=</span> inter_list[it<span class="op">+</span><span class="dv">1</span>] <span class="op">-</span> inter_list[it]<span class="op">;</span></span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a>    nit <span class="op">=</span> list_npoints_inter[it]</span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true" tabindex="-1"></a>    varpi <span class="op">+=</span> δa <span class="op">*</span> δa <span class="op">*</span> ( list_sum_inter2[it] <span class="op">-</span> nit <span class="op">*</span> list_mean_inter[it] <span class="op">*</span> list_mean_inter[it] )<span class="op">/</span>(nit <span class="op">*</span> (nit <span class="op">-</span> <span class="dv">1</span>))<span class="op">;</span></span>
<span id="cb8-36"><a href="#cb8-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-37"><a href="#cb8-37" aria-hidden="true" tabindex="-1"></a>errorpi <span class="op">=</span> np.sqrt(varpi)</span>
<span id="cb8-38"><a href="#cb8-38" aria-hidden="true" tabindex="-1"></a>exactI<span class="op">=</span><span class="fl">0.4180232931306735</span></span>
<span id="cb8-39"><a href="#cb8-39" aria-hidden="true" tabindex="-1"></a>exactI<span class="op">=</span>np.pi<span class="op">/</span><span class="dv">4</span></span>
<span id="cb8-40"><a href="#cb8-40" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&#39;meanpi = </span><span class="sc">{</span>meanpi<span class="sc">}</span><span class="ss"> exact=</span><span class="sc">{</span>exactI<span class="sc">}</span><span class="ss"> </span><span class="ch">\n</span><span class="ss"> error=</span><span class="sc">{</span>errorpi<span class="sc">}</span><span class="ss"> errorExact=</span><span class="sc">{</span>exactI<span class="op">-</span>meanpi<span class="sc">}</span><span class="ss">&#39;</span>)</span></code></pre></div></li>
</ol>
<h3 id="code-output-2">Code (output)</h3>
<pre class="example"><code>meanpi = 0.7831097344059315 exact=0.7853981633974483
 error=0.024708860632964468 errorExact=0.002288428991516822</code></pre>
<h2 id="importance-sampling">Importance sampling</h2>
<p>The natural next step following stratified sampling is that of
importance sampling. In the previous method, we chose the strata
arbitrarily, i.e. by inspection of the function to integrate. This was
followed by a uniform sampling of points inside each strata. The idea is
to break the domain into regions which need to be sampled with more
points as opposed to domains where the function is quasi horizontal
(i.e. low variance). The more natural way to do this is to adapt the
choice of points in a more flexible manner. This is the idea behind
importance sampling where we define a custom distribution (<span
class="math inline">\(g(x)\)</span>) which is very close to the original
function (<span class="math inline">\(f(x)\)</span>) that we wish to
integrate. The main constarint on the distribution is that it needs to
be easy to sample from.</p>
<p><span class="math display">\[
\theta = \int_0^1 f(x)\ dx = \int_0^1 \frac{f(x)}{g(x)} g{x}\ dx =
\int_0^1 \frac{f(x)}{g(x)} dG(x)
\]</span></p>
<p>here, <span class="math inline">\(dG(x)\)</span> is the measure, i.e.
the sampling distribution. Note that the distribution <span
class="math inline">\(g(x)\)</span> must be normalized.</p>
<p><span class="math display">\[
\int_0^1 g(x)dx = 1
\]</span></p>
<p>Invting a distribution,</p>
<h3 id="code-3">Code</h3>
<ol type="1">
<li><p>Function</p>
<div class="RESULTS drawer">

<p><img src="figures/sampling_function.png" /></p>
</div>

<p>The above figure shows the distribution function that we shall use.
There are many points close to <span
class="math inline">\(x\approx0\)</span> and the points progressively
decrease as we approach <span
class="math inline">\(x\approx1\)</span>.</p></li>
<li><p>Simulation</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>nb<span class="op">=</span><span class="dv">22</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>corrlen<span class="op">=</span><span class="dv">0</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>npoints<span class="op">=</span>(<span class="dv">1</span> <span class="op">&lt;&lt;</span> nb )</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>npointsall<span class="op">=</span>(<span class="dv">1</span> <span class="op">&lt;&lt;</span> nb ) <span class="op">+</span> corrlen</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>randvals <span class="op">=</span> [cdfm1(x) <span class="cf">for</span> x <span class="kw">in</span> np.random.rand(npointsall)]</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate via MC simul</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>pivals <span class="op">=</span> [foverg(x) <span class="cf">for</span> x <span class="kw">in</span> randvals]</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>meanpi <span class="op">=</span> st.mean(pivals)</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>meanpilist <span class="op">=</span> meanpi<span class="op">*</span>np.ones(npoints)<span class="op">;</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>varpivals <span class="op">=</span> [pi_curve_var(x) <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">zip</span>(pivals,meanpilist)]</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>errorpi<span class="op">=</span>np.sqrt(np.<span class="bu">sum</span>(varpivals)<span class="op">/</span>(npoints<span class="op">-</span><span class="dv">1</span>))<span class="op">/</span>np.sqrt(npoints)</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>exactI<span class="op">=</span>np.pi<span class="op">/</span><span class="dv">4</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&#39;meanpi = </span><span class="sc">{</span>meanpi<span class="sc">}</span><span class="ss"> exact=</span><span class="sc">{</span>exactI<span class="sc">}</span><span class="ss"> </span><span class="ch">\n</span><span class="ss"> error=</span><span class="sc">{</span>errorpi<span class="sc">}</span><span class="ss"> errorExact=</span><span class="sc">{</span>exactI<span class="op">-</span>meanpi<span class="sc">}</span><span class="ss">&#39;</span>)</span></code></pre></div></li>
</ol>
<h3 id="coderesults">Code(results)</h3>
<pre class="example"><code>meanpi = 0.7858500513037664 exact=0.7853981633974483
 error=0.0008344871199825027 errorExact=-0.0004518879063181158</code></pre>
</body>
</html>
