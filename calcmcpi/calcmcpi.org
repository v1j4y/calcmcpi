:HEADER:
#+TITLE:     Calculate Pi using monte-carlo methods
#+AUTHOR: Vijay Gopal Chilkuri
#+EMAIL: vijay.gopal.c@gmail.com
#+DATE: <2023-08-19 sam.>
#+LaTeX_Header: \documentclass[fleqn]{article}
#+LaTeX_Header: \usepackage{amsmath,amssymb}
#+LaTeX_Header: \newcommand*\Laplace{\mathop{}\!\mathbin\bigtriangleup}
#+STARTUP: showall indent latexpreview entitiespretty
:END:

* Setup :noexport:
:SETUP:
#+NAME: importall
#+begin_src python :session p1 :results silent :noweb yes
import numpy as np
import statistics as st
from scipy.integrate import odeint
from scipy import integrate
from scipy import interpolate
from scipy.optimize import root_scalar
import matplotlib.pyplot as plt
from copy import deepcopy
#+end_src
:END:

* Introduction
:PROPERTIES:
:header-args:python: :async :session p1
:END:

The one dimensional integral that we shall evaluate
using monte-carlo methods gives the area of the
a quarter of the unit circle. Using this and the fact that the
analytical value of the are of a quarter of the unit circle is
given as $\pi/4$, we can find the value of $\pi$.

$$
\theta = \int_0^1 \sqrt{1-x^2}\ dx = \frac{\pi}{4}
$$

#+ATTR_ORG: :width 400
#+ATTR_LATEX: :width 4in
[[../figures/area_quarter_unit_circle.png]]

The goal is to understand the strengths and weaknesses of
the various monte-carlo methods for the purpose of
numerical integration.

* Monte-Carlo methods
:PROPERTIES:
:header-args:python: :async :session p1
:END:

Here, we shall test the various algorithms for
numerical integration and check their labour ratio.

** Crude monte-carlo

The crude method is the simplest and most inefficient
monte-carlo algorithm. It simply involves generating
uniformly distributed random points inside the unit
square and counting the ratio of those points that lie
within the quarter circle. This gives us the ratio of
the area of the square and the circle. Since the are
of the unit square is 1, the are of the circle can be
deduced directly.

#+ATTR_ORG: :width 400
#+ATTR_LATEX: :width 4in
[[../figures/crude_sampling.png]]

The algorithm involves simply generating uniformly
distributed set of points within the range (0-1).

** Code

*** Functions
#+begin_src python :results none
def pi_curve(x):
    return(np.sqrt(1.0 - x*x))

def pi_curve_var(inp):
    (x, meanpi) = inp
    return((x-meanpi)**2)
#+end_src

*** Simulation
#+begin_src python :results none
nb=24
corrlen=0
npoints=(1 << nb )
npointsall=(1 << nb ) + corrlen
randvals = np.random.rand(npointsall);
pivalslist=np.zeros(npointsall);

# Calculate via MC simul
meanpi = st.mean(map(pi_curve, randvals))
pivals = map(pi_curve, randvals)
meanpilist = meanpi*np.ones(npoints);
varpivals = map(pi_curve_var, zip(pivals,meanpilist))
errorpi=np.sqrt(sum(varpivals)/(npoints-1))/np.sqrt(npoints)
# Ï€
exactI=np.pi/4
print(f'meanpi = {meanpi} exact={exactI} \n error={errorpi} errorExact={exactI-meanpi}')

#+end_src
